     1                                  ;マクロ
     2                                  
     3                                  %include    "../include/define.s"
     1                              <1>         BOOT_SIZE       equ     (1024 * 8)                      ; boot size
     2                              <1>         KERNEL_SIZE     equ     (1024 * 8)                      ; kernel size
     3                              <1> 
     4                              <1>         BOOT_LOAD       equ     0x7c00                          ;ブートプログラムのロード位置
     5                              <1>         BOOT_END        equ     (BOOT_LOAD + BOOT_SIZE)
     6                              <1> 
     7                              <1>         KERNEL_LOAD     equ     0x0010_1000
     8                              <1> 
     9                              <1>         SECT_SIZE       equ     (512)                           ;セクタサイズ
    10                              <1> 
    11                              <1>         BOOT_SECT       equ     (BOOT_SIZE / SECT_SIZE)         ;ブートプログラムのセクタ数
    12                              <1>         KERNEL_SECT     equ     (KERNEL_SIZE / SECT_SIZE)
    13                              <1> 
    14                              <1>         E820_RECORD_SIZE        equ     20
     4                                  %include    "../include/macro.s"
     1                              <1> %macro  cdecl 1-*.nolist
     2                              <1> 
     3                              <1>     %rep  %0 - 1
     4                              <1>         push    %{-1:-1}
     5                              <1>         %rotate -1
     6                              <1>     %endrep
     7                              <1>     %rotate -1
     8                              <1> 
     9                              <1>         call    %1
    10                              <1> 
    11                              <1>     %if 1 < %0
    12                              <1>         add     sp, (__BITS__ >> 3) * (%0 - 1)
    13                              <1>     %endif
    14                              <1> 
    15                              <1> %endmacro
    16                              <1> 
    17                              <1> struc   drive                               ;セクタ読み出し時のパラメータを構造体で定義
    18 00000000 <res 00000002>      <1>             .no         resw    1           ;ドライブ番号
    19 00000002 <res 00000002>      <1>             .cyln       resw    1           ;シリンダ
    20 00000004 <res 00000002>      <1>             .head       resw    1           ;ヘッド
    21 00000006 <res 00000002>      <1>             .sect       resw    1           ;セクタ
    22                              <1> endstruc
     5                                  
     6                                                  ORG     KERNEL_LOAD                             ; load address of kernel
     7                                  
     8                                  [BITS 32]                                                       ; BIT 32 directive
     9                                  ; entry point
    10                                  
    11                                  kernel:
    12                                  
    13                                                  ; Get Font address
    14 00000000 BE007E0000                              mov     esi, BOOT_LOAD + SECT_SIZE              ; ESI = 0x7x00 + 512
    15 00000005 0FB706                                  movzx   eax, word [esi + 0]                     ; segment
    16 00000008 0FB75E02                                movzx   ebx, word [esi + 2]                     ; offset
    17 0000000C C1E004                                  shl     eax, 4
    18 0000000F 01D8                                    add     eax, ebx
    19 00000011 A3[D8000000]                            mov     [FONT_ADR], eax                             ; FONT[0] = EAX
    20                                  
    21                                                  ; 8 bit horizontal line
    22 00000016 B407                                    mov     ah, 0x07                                ; AH = specify writing plane(Bit:----IRGB)
    23 00000018 B002                                    mov     al, 0x02                                ; AL = map mask register(specify writing plane)
    24 0000001A 66BAC403                                mov     dx, 0x03C4                              ; DX = sequencer control port(address register)
    25 0000001E 66EF                                    out     dx, ax
    26                                  
    27 00000020 C60500000A00FF                          mov     [0x000A_0000 + 0], byte 0xFF
    28                                  
    29 00000027 B404                                    mov     ah, 0x04
    30 00000029 66EF                                    out     dx, ax
    31                                  
    32 0000002B C60501000A00FF                          mov     [0x000A_0000 + 1], byte 0xFF
    33                                  
    34 00000032 B402                                    mov     ah, 0x02
    35 00000034 66EF                                    out     dx, ax
    36                                  
    37 00000036 C60502000A00FF                          mov     [0x000A_0000 + 2], byte 0xFF
    38                                  
    39 0000003D B401                                    mov     ah, 0x01
    40 0000003F 66EF                                    out     dx, ax
    41                                  
    42 00000041 C60503000A00FF                          mov     [0x000A_0000 + 3], byte 0xFF
    43                                  
    44                                                  ; a horizontal line crossing the screen
    45 00000048 B402                                    mov     ah, 0x02                                ; AH = (Bit:----IRGB)
    46 0000004A 66EF                                    out     dx, ax
    47                                  
    48 0000004C 8D3D50000A00                            lea     edi, [0x000A_0000 + 80]                 ; EDI = VRAM address
    49 00000052 B950000000                              mov     ecx, 80                                 ; repeat num of times
    50 00000057 B0FF                                    mov     al, 0xFF
    51 00000059 F3AA                                    rep     stosb                                   ; stosb: [EDI] = AL
    52                                                                                                  ; *EDI++ = AL
    53                                  
    54                                                  ; 8 dot rectangle
    55 0000005B BF01000000                              mov     edi, 1                                  ; EDI = num of lines
    56                                  
    57 00000060 C1E708                                  shl     edi, 8                                  ; EDI *= 256
    58 00000063 8DBCBF00000A00                          lea     edi, [edi * 4 + edi + 0xA_0000]         ; EDI*4 + EDI == EDI + 1280(one line) // VRAM address
    59                                  
    60 0000006A 66C707FF00                              mov     [edi + (80 * 0)], word 0xFF
    61 0000006F 66C74750FF00                            mov     [edi + (80 * 1)], word 0xFF
    62 00000075 66C787A0000000FF00                      mov     [edi + (80 * 2)], word 0xFF
    63 0000007E 66C787F0000000FF00                      mov     [edi + (80 * 3)], word 0xFF
    64 00000087 66C78740010000FF00                      mov     [edi + (80 * 4)], word 0xFF
    65 00000090 66C78790010000FF00                      mov     [edi + (80 * 5)], word 0xFF
    66 00000099 66C787E0010000FF00                      mov     [edi + (80 * 6)], word 0xFF
    67 000000A2 66C78730020000FF00                      mov     [edi + (80 * 7)], word 0xFF
    68                                  
    69                                                  ; put char
    70                                  ;                 mov     esi, 'A'                                ; ESI = char code
    71                                  ;                 shl     esi, 4                                  ; ESI *= 16
    72                                  ;                 add     esi, [FONT_ADR]                         ; ESI += FONT_ADR[char code]
    73                                  
    74                                  ;                 mov     edi, 2                                  ; num of lines
    75                                  ;                 shl     edi, 8                                  ; EDI *= 256
    76                                  ;                 lea     edi, [edi * 4 + edi + 0xA_0000]         ; VRAM address
    77                                  
    78                                  ;                 mov     ecx, 16                                 ; height of one char
    79                                  ; .10L:
    80                                  ;                 movsb                                           ; [DI] = [SI]
    81                                  ;                 add     edi, 80 - 1
    82                                  ;                 loop    .10L                                    ; while(--ECX)
    83                                  
    84 000000AB BE41000000              		mov		esi, 'A'						; ESI  = �����R�[�h;
    85 000000B0 C1E604                  		shl		esi, 4							; ESI *= 16;
    86 000000B3 0335[D8000000]          		add		esi, [FONT_ADR]					; ESI  = FONT_ADR[�����R�[�h];
    87                                  
    88 000000B9 BF02000000              		mov		edi, 2							; EDI  = �s��;
    89 000000BE C1E708                  		shl		edi, 8							; EDI *= 256;
    90 000000C1 8DBCBF00000A00          		lea		edi, [edi * 4 + edi + 0xA_0000]	; EDI  = VRAM�A�h���X;
    91                                  
    92 000000C8 B910000000              		mov		ecx, 16							; ECX  = 16;
    93                                  .10L:											; do
    94                                  												; {
    95 000000CD A4                      		movsb									;   *EDI++ = *ESI++;
    96 000000CE 83C74F                  		add		edi, 80 - 1						;   EDI += 79; // 1�h�b�g��
    97 000000D1 E2FA                    		loop	.10L							; }while (--ECX);
    98                                  
    99                                                  ; End of Process
   100 000000D3 EBFE                                    jmp     $
   101                                  
   102 000000D5 00<rept>                ALIGN 4, db 0
   103 000000D8 00000000                FONT_ADR:   dd 0
   104                                  
   105                                                  ; Padding
   106                                  
   107 000000DC 00<rept>                                times   KERNEL_SIZE - ($ - $$)      db 0x00     ; size of kernel // 8K byte
